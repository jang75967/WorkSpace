# 프론트엔드 패턴

## 웹 프론트엔드를 바닐라로 만들다보면 꼭 나오는 주제

- 규모가 점점 커지고 있다.
- 프론트도 객체지향 프로그래밍을 할 수 있지 않을까?
- MVC 프레임워크 적용한다면?

#### 프론트엔드 트렌드 변천사

> HTML, CSS, JS의 탄생 : 관심의 분리와 느슨한 결합
> jQuery 시대 : DOM을 쉽게 쓰자
> HTML + JS 합치니까 더 낫다? - MVC 컴포넌트 방식의 탄생
> 선언적으로 만들자 - 데이터 바인딩 + 템플릿 => MVVM 웹 프레임워크 탄생
> 컴포넌트 간 데이터 교환이 너무 복잡하고 어렵다. - Container-Presenter 방식
> Props Drill 문제 해결 - Flux와 Redux
> 너무 복잡하다 - hooks와 context, Recoil, Zustand, jotai
> 대부분 서버 API 관리를 위해 사용하는 용도일텐데? - React Query, Redux Query

1. HTML, CSS, JS의 탄생 : 관심의 분리와 느슨한 결합

- HTML, JS 다음 CSS 순서대로 탄생하여 각자의 방식대로 성장
- HTML은 서버가 작성하는 영역
- JS는 간단한 동작
- CSS는 화면 관리

2. jQuery 시대 : DOM을 쉽게 쓰자

- Ajax 탄생으로 서버에서 HTML 만들지 않고 데이터만 교환 가능하게 됨
- JS를 이용해 데이터로 DOM을 조작하는 작업이 중요해짐
- jQuery 같은 Ajax, DOM 잘 다룰 수 있는 라이브러리 사용

3. HTML + JS 합치니까 더 낫다? - MVC 컴포넌트 방식의 탄생

- HTML과 JS를 함께 다루는 편이 더 나았고 이후 앱을 만들던 MVC 아키텍쳐를 표방
- 데이터를 조작하고 DOM을 조작하는 로직을 하나로 관리하는 방향으로 발전
- 화면 단위가 아닌 컴포넌트 단위로 발전

4. 선언적으로 만들자 - 데이터 바인딩 + 템플릿 => MVVM 웹 프레임워크 탄생

- 매번 데이터 변경 때마다 템플릿 방식으로 HTML을 작성하는 방안이 자동화되어 Angaulr, React, Vue 등 발전

5. 컴포넌트 간 데이터 교환이 너무 복잡하고 어렵다. - Container-Presenter 방식

- 데이터가 많아지고 로직이 분리되면서 점점 복잡해지는 컴포넌트
- 재사용성이 떨어지면서 **데이터를 받아서 보여주기만 하는 'Prsenter형 컴포넌트'** 와 **데이터 요청 및 처리의 'Container형 컴포넌트** 로 분리
- Container에서 props를 Presenter로 내려주면서 로직을 한군데에 모으고 화면을 다루는 View 방식이 재사용 형태의 주류 아키텍처로 적용

6. Props Drill 문제 해결 - Flux와 Redux

- 상위 props들이 하위로 전달되는 과정에서 중간 컴포넌트를 불필요하게 거쳐가야 하는 문제 발생 (단단한 결합)
- 비즈니스 로직을 굳이 컴포넌트 계층 구조로 만들 필요 없이 View와 비즈니스 로직을 분리한 단방향 데이터 구조를 가지는 Flux 패턴, Redux 등 도입 (상태관리)

7. 너무 복잡하다 - hooks와 context, Recoil, Zustand

- 컨셉은 좋으나 과한 문법 체계인 Redux는 대형 프로젝트 외에 오버엔지니어링 발생
- 너무 많은 보일러플레이트 코드
- hooks (useState, useEffect 등) 을 통해 간결한 문법으로 외부 비즈니스 로직을 쉽게 연동
- React에서 기본적으로 제공하는 hook API만으론 전역 상태관리가 용이하지 않아, **전역객체를 이용해 데이터를 기록하고 변경감지를 통해 View로 전달** 하는 형태인 Recoil, Zustands 등 제시

8. 대부분 서버 API 관리를 위해 사용하는 용도일텐데? - React Query, Redux Query

- 대부분의 프론트엔드에서 전역적인 상태관리가 필요한 이유는 서버와 API
- 웹 특성상 데이터의 보관과 조회, 수정이 서버에서 이루어져야 하고, 비즈니스 로직이 대부분 백엔드에 보관된다.
- **백엔드와 직접 연동해 기존 상태관리에서 로딩, 캐싱, 무효화, 업데이트 등 복잡하게 진행하던 로직들을 단순하게 만들어주는 방식 탄생**

////////////////////////////////////////////////////

#### MVC 백엔드 수행 절차

- client의 **request**를 받는다.
- request를 **분석**한다. (Routing)
- 필요한 **데이터를 수집/가공** 한다.
- **뷰를 생성**하고 response 한다. (client에 보여줄 웹페이지)

[이미지1]

**문제점 (강한의존성)**

**각각의 Layer들이 다음 단계의 Layer의 존재를 알고 있어야 한다.**

- Controller는 Model을 알아야 한다.
- Model은 View를 알아야 한다.(호출해야 한다.)
- View는 Controller를 호출해서 결과 응답한다.

**MVC 실제 사용방법**

**완전한 의존성 제거는 하지 못하지만 중간계층인 Controller에 많은 역할을 부여해 어느정도 해결한다.**

- Controller가 Model을 통해 데이터 수집, 가공 요청해 받아온다.
- 받아온 Model 정보를 View에 전달한다.

[이미지2]

```js
model = new Model();
view = new view(model);
view.makeHTML();
```

## 프론트도 MVC 사용하면 될까?

#### 보통 MVC에서 View는 만들어지는 결정체일뿐

- 옛날 웹페이지와 다르게 요즘 프론트는 복잡한 view가 많아짐
- 프론트는 모두 View라고 할 수 있다.
- 프론트엔드에서의 View는 **온갖 이벤트**가 발생한다.

[이미지3]

#### 프론트엔드의 특성을 Model과 View의 관계로 정리해보면?

- View의 변경으로 Model을 바꿔야 하는 경우

[이미지4]

- Model의 변경으로 View를 바꿔야 하는 경우

[이미지5]

[이미지6]

> View와 Model이 양방향으로 인터렉션 일어난다. (강한 의존성)
> 프론트엔드의 View는 매우 많다.
> 프론트엔드 구현 복잡도가 올라간다.
> Controller를 둔다고 해도 Controller의 역할이 너무 많아진다.

[이미지7]

#### [프론트엔드 특징 한가지] View는 계층적인 구조를 가지는게 필요하다.

- View는 DOM을 표현하는 것 (트리구조)
- 우리가 View를 나눌때도 DOM만큼 잘게 나누진 않지만, 어느 정도의 트리구조를 가지면서 제어하도록 설계되어야 한다.
- 리렌더링(DOM 조작)이 잦기 때문에 거대한 View를 계속 리렌더링 하기보단, 잘게 나눈 단위로 리렌더링이 효율적

[이미지8]

> > > 정리 : 프론트엔드는

- view가 매우 많다.
- 양방향 처리가 필요하다.
- Controller 제어 시 Controller의 역할이 매우 커진다.
- view 간 계층처리가 필요하다.

> > > 필요한 것,

- 복잡한 View와 Model 관계 단순화
- viEW 계층처리로 쉽고 효율적인 DOM 처리

==> 일반적인 MVC 방식으론 쉽지 않다. (패턴을 위한 코드를 만들 필요는 없다.)

## 요즘 프론트엔드에서 사용되는 기술들

- 데이터 바인딩
- MVVM
- Flux 아키텍쳐

#### 데이터 바인딩

- View <-> Model 자동 변경
- 프레임워크 사용하지 않고 구현하려면 defineProperty, proxy API, 옵저버패턴 등으로 구현해야 한다.

```js
// Svelte 예시
<script>
let name = 'world';
</script>

<h1>Hello {name}!</h1>

<input bind:value={name}/>
```

#### MVVM

- View에 변경 사항 일어나면 ViewModel 적용
- ViewModel이 바뀌면 View에 변경사항 업데이트

[이미지9]

#### Vue.js 에서 MVVM 프레임워크 지원

[이미지10]

#### React Flux 아키텍쳐

- 한방향으로 흐름을 제어하며 동작

- View에서 변경 사항 생기면 Dispatch 발생
- Dispatcher를 통해 Store에 전달
- Store에 변경 사항 있으면 다시 View로 바뀜

[이미지11]

////// 노션 정리 글 캡쳐 ㄱㄱ

#### React 상태관리 라이브러리

- Flux 아키텍쳐 따라 만들거나
- Store가 바뀌면 View를 렌더링한다.

[이미지12]

> > > > 요약

- 프론트엔드는 View가 많고 인터렉션도 많다.
- 프론트엔드는 아키텍쳐와 패턴은 더 나은 선택이 필요하다.
- MVVM, Flux 등의 패턴이 유용하게 쓰인다.
